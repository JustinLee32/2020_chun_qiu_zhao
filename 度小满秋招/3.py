# 树上的最大值
# 时间限制：C/C++语言 1000MS；其他语言 3000MS
# 内存限制：C/C++语言 65536KB；其他语言 589824KB
# 题目描述：
# 给定一棵有n个点的树，树上的边有边权。现在需要你选出m个黑点，剩下的点为白点。你的任务是让黑点两两之间的距离加上白点两两之间的距离最大。输出这个最大值。
#
# 树上两个点的距离定义为这两个点之间路径的长度。
#
# 输入
# 第一行两个数n，m，代表点数和黑点数
#
# 接下来n-1行，每行三个数u,v,w，代表u点到v点有一条权值为w的边。
#
# 保证给出的边连接成一棵树
#
# 1≤n≤5000,1≤m≤n,1≤w≤106
#
# 输出
# 输出一行一个数，代表这个最大值

# 样例输入
# 5 3
# 1 2 1
# 2 3 1
# 2 4 2
# 3 5 2
# 样例输出
# 13
#
# 提示
# 样例解释：选择1 4 5为黑点，这样1,4,5为黑点，1到4的距离为3,1到5的距离为4,4到5的距离为5。2,3为白点，2到3的距离为1，故答案为3+4+5+1=13

[n, m] = list(map(int, input().split()))
edges = []
for _ in range(n - 1):
    edges.append(tuple(map(int, input().split())))
ans = 0


